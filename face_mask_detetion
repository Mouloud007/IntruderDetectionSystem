import cv2
from flask import Flask, Response
from ultralytics import YOLO
import paho.mqtt.client as mqtt
import json
import time
import sqlite3
import numpy as np
import face_recognition

# Flask app
app = Flask(__name__)

# MQTT configuration
mqtt_broker = "localhost"
mqtt_port = 1883
mqtt_topic_intruder = "home/intruder_alert"
mqtt_topic_known_person = "home/known_person"

# Initialize MQTT client
client = mqtt.Client()

# MQTT Connection Callback
def on_connect(client, userdata, flags, rc):
    if rc == 0:
        print("‚úÖ Connected to MQTT Broker!")
    else:
        print(f"‚ùå Failed to connect to MQTT Broker. Return code: {rc}")

client.on_connect = on_connect
client.connect(mqtt_broker, mqtt_port, 60)
client.loop_start()  # Start MQTT processing loop

# Load YOLOv8 model
model = YOLO("yolov8n.pt")

# Open webcam
cap = cv2.VideoCapture(0)
cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)

# Load known faces from the database
def load_known_faces():
    conn = sqlite3.connect("faces.db")
    cursor = conn.cursor()
    cursor.execute("SELECT name, encoding FROM known_faces")
    known_faces = []
    known_names = []

    for row in cursor.fetchall():
        name, encoding_blob = row
        encoding = np.frombuffer(encoding_blob, dtype=np.float64)
        known_faces.append(encoding)
        known_names.append(name)

    conn.close()
    
    print(f"‚úÖ Loaded {len(known_faces)} known faces from the database")
    return known_faces, known_names

known_faces, known_names = load_known_faces()

# Cooldown period to avoid spamming alerts (in seconds)
ALERT_COOLDOWN = 10  
last_intruder_alert_time = 0
last_known_person_alert_time = 0

# Counter for incremental alerts
intruder_counter = 0
known_person_counter = 0

def generate_frames():
    global last_intruder_alert_time, last_known_person_alert_time
    global intruder_counter, known_person_counter

    while True:
        success, frame = cap.read()
        if not success:
            print("‚ùå Failed to capture frame from webcam")
            break

        # Run YOLO detection
        results = model(frame)
        detected_objects = results[0].boxes.cls.tolist()

        print(f"üéØ Detected objects: {detected_objects}")  # Debug YOLO detections

        intruder_detected = False
        known_person_detected = False
        detected_person = False  

        for obj in detected_objects:
            if obj == 0:  # Person detected
                detected_person = True
                face_locations = face_recognition.face_locations(frame)
                face_encodings = face_recognition.face_encodings(frame, face_locations)

                print(f"üëÄ Faces detected: {len(face_encodings)}")  

                for face_encoding in face_encodings:
                    matches = face_recognition.compare_faces(known_faces, face_encoding)
                    name = "Unknown"

                    if True in matches:
                        best_match_index = np.argmax(face_recognition.face_distance(known_faces, face_encoding))
                        name = known_names[best_match_index]
                        known_person_detected = True
                        print(f"‚úÖ Recognized: {name}")  

                    else:
                        intruder_detected = True
                        print("üö® Intruder detected !!!!!!")

                    # Draw boxes around detected faces
                    for (top, right, bottom, left) in face_locations:
                        color = (0, 255, 0) if name != "Unknown" else (0, 0, 255)
                        cv2.rectangle(frame, (left, top), (right, bottom), color, 2)
                        cv2.putText(frame, name, (left, top - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.8, color, 2)

        if not detected_person:
            print("‚ö†Ô∏è No persons detected by YOLO.")

        # If an intruder is detected, send an MQTT alert
        if intruder_detected and (time.time() - last_intruder_alert_time) > ALERT_COOLDOWN:
            intruder_counter += 1  
            alert_message = {
                "alert": f"üö® Intruder {intruder_counter} detected!",
                "timestamp": time.strftime('%Y-%m-%d %H:%M:%S', time.localtime()),
                "location": "Camera feed",
                "status": "Unknown person detected",
                "unique_id": time.time()
            }

            result = client.publish(mqtt_topic_intruder, json.dumps(alert_message))
            if result.rc == 0:
                print(f"‚úÖ Sent intruder alert: {alert_message}")
                last_intruder_alert_time = time.time()  
            else:
                print(f"‚ùå Failed to send MQTT alert. Return code: {result.rc}")

        # If a known person is detected, send an MQTT alert
        if known_person_detected and (time.time() - last_known_person_alert_time) > ALERT_COOLDOWN:
            known_person_counter += 1
            known_alert_message = {
                "alert": f"üòä Known person detected: {name}",
                "timestamp": time.strftime('%Y-%m-%d %H:%M:%S', time.localtime()),
                "location": "Camera feed",
                "status": f"{name} has been recognized",
                "unique_id": time.time()
            }

            result = client.publish(mqtt_topic_known_person, json.dumps(known_alert_message))
            if result.rc == 0:
                print(f"‚úÖ Sent known person alert: {known_alert_message}")
                last_known_person_alert_time = time.time()
            else:
                print(f"‚ùå Failed to send MQTT alert. Return code: {result.rc}")

        # Encode frame as JPEG
        _, buffer = cv2.imencode('.jpg', frame)
        frame = buffer.tobytes()
        yield (b'--frame\r\n'
               b'Content-Type: image/jpeg\r\n\r\n' + frame + b'\r\n')

@app.route('/video_feed')
def video_feed():
    return Response(generate_frames(), mimetype='multipart/x-mixed-replace; boundary=frame')

if __name__ == "__main__":
    print("üöÄ Intruder detection system started. Access video feed at: http://<RASPBERRY_PI_IP>:5000/video_feed")
    app.run(host='0.0.0.0', port=5000, debug=False)
