import cv2
from flask import Flask, Response
from ultralytics import YOLO
import paho.mqtt.client as mqtt
import json
import time
import sqlite3
import numpy as np
import face_recognition
import threading
import smtplib
from email.message import EmailMessage
import os
import atexit

app = Flask(__name__)

# MQTT Configuration
mqtt_broker = "localhost"
mqtt_port = 1883
mqtt_topic_intruder = "home/intruder_alert"

# Email Configuration
EMAIL_SENDER = os.getenv("EMAIL_SENDER", "your_email@gmail.com")
EMAIL_PASSWORD = os.getenv("EMAIL_PASSWORD", "your_app_password")
EMAIL_RECEIVER = os.getenv("EMAIL_RECEIVER", "receiver_email@gmail.com")
EMAIL_COOLDOWN = 10
last_email_time = 0
email_lock = threading.Lock()

# MQTT Client
client = mqtt.Client()

def on_connect(client, userdata, flags, rc):
    if rc == 0:
        print("‚úÖ Connected to MQTT Broker!")
    else:
        raise ConnectionError(f"‚ùå Failed to connect to MQTT Broker. Return code: {rc}")

client.on_connect = on_connect
try:
    client.connect(mqtt_broker, mqtt_port, 60)
except Exception as e:
    print(f"‚ùå MQTT connection error: {e}")
client.loop_start()

# Load YOLO Models
old_model = YOLO("yolov8n.pt")
mask_model_path = "/home/mouloudelg/Desktop/New Model/trained_mask_model.pt"
if not os.path.exists(mask_model_path):
    raise FileNotFoundError(f"‚ùå Mask model file not found at {mask_model_path}")
new_model = YOLO(mask_model_path)

# Open Webcam
cap = cv2.VideoCapture(0)
if not cap.isOpened():
    raise RuntimeError("‚ùå Could not open webcam. Check connection or permissions.")
cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)

def load_known_faces():
    conn = sqlite3.connect("faces.db")
    cursor = conn.cursor()
    try:
        cursor.execute("SELECT name, encoding FROM known_faces")
        known_faces = []
        known_names = []
        for row in cursor.fetchall():
            name, encoding_blob = row
            encoding = np.frombuffer(encoding_blob, dtype=np.float64)
            known_faces.append(encoding)
            known_names.append(name)
    except sqlite3.OperationalError:
        print("‚ùå Database table 'known_faces' not found. Starting with empty face list.")
        known_faces, known_names = [], []
    conn.close()
    print(f"‚úÖ Loaded {len(known_faces)} known faces from the database")
    return known_faces, known_names

known_faces, known_names = load_known_faces()

ALERT_COOLDOWN = 10
last_intruder_alert_time = 0
intruder_counter = 0

def send_email_alert():
    global last_email_time
    if (time.time() - last_email_time) < EMAIL_COOLDOWN:
        print("üìß Email alert skipped due to cooldown.")
        return
    if email_lock.acquire(blocking=False):
        def email_task():
            try:
                msg = EmailMessage()
                msg["Subject"] = "üö® Intruder Alert!"
                msg["From"] = EMAIL_SENDER
                msg["To"] = EMAIL_RECEIVER
                msg.set_content("An intruder has been detected!")
                with smtplib.SMTP("smtp.gmail.com", 587) as server:
                    server.starttls()
                    server.login(EMAIL_SENDER, EMAIL_PASSWORD)
                    server.send_message(msg)
                    print("üìß Email alert sent successfully!")
                    global last_email_time
                    last_email_time = time.time()
            except Exception as e:
                print(f"‚ùå Failed to send email alert: {e}")
            finally:
                email_lock.release()
        threading.Thread(target=email_task, daemon=True).start()
    else:
        print("üìß Email sending skipped: another email is in progress.")

def generate_frames():
    global last_intruder_alert_time, intruder_counter
    while True:
        success, frame = cap.read()
        if not success:
            print("‚ùå Failed to capture frame from webcam")
            break

        # Old model (person detection)
        old_results = old_model(frame)
        old_detected_objects = old_results[0].boxes.cls.tolist()
        old_boxes = old_results[0].boxes.xyxy.tolist()

        # New model (mask detection)
        new_results = new_model(frame)
        new_detected_objects = new_results[0].boxes.cls.tolist()
        new_boxes = new_results[0].boxes.xyxy.tolist()
        new_confidences = new_results[0].boxes.conf.tolist()

        intruder_detected = False
        for i, obj in enumerate(old_detected_objects):
            if obj == 0:  # Person detected
                x1, y1, x2, y2 = map(int, old_boxes[i])
                face_region = frame[y1:y2, x1:x2]
                face_region_rgb = cv2.cvtColor(face_region, cv2.COLOR_BGR2RGB)
                face_locations = face_recognition.face_locations(face_region_rgb)
                face_encodings = face_recognition.face_encodings(face_region_rgb, face_locations)

                for face_encoding in face_encodings:
                    matches = face_recognition.compare_faces(known_faces, face_encoding)
                    name = "Unknown"
                    if True in matches:
                        best_match_index = np.argmin(face_recognition.face_distance(known_faces, face_encoding))
                        name = known_names[best_match_index]
                        print(f"‚úÖ Recognized: {name}")
                    else:
                        intruder_detected = True
                        print("üö® Intruder detected !!!!!!")
                    color = (0, 255, 0) if name != "Unknown" else (0, 0, 255)
                    cv2.rectangle(frame, (x1, y1), (x2, y2), color, 2)
                    cv2.putText(frame, name, (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.8, color, 2)

        # Handle mask detection (single grid logic)
        mask_status = "No Mask"  # Default to "No Mask" if no strong detection
        mask_confidence = 0.0
        mask_box = None

        for i, obj in enumerate(new_detected_objects):
            class_id = int(obj)
            confidence = float(new_confidences[i])
            x1, y1, x2, y2 = map(int, new_boxes[i])
            print(f"New model detected - Class ID: {class_id}, Confidence: {confidence:.2f}, Box: ({x1}, {y1}, {x2}, {y2})")

            # Update mask status based on highest confidence and class
            if class_id == 1 and confidence > 0.7:  # High confidence "mask"
                mask_status = "Mask"
                mask_confidence = confidence
                mask_box = (x1, y1, x2, y2)
                break  # Prioritize "mask" if confident
            elif (class_id == 0 or (class_id == 1 and confidence < 0.7)) and confidence > mask_confidence:
                mask_status = "No Mask"
                mask_confidence = confidence
                mask_box = (x1, y1, x2, y2)

        # Draw only one grid based on the determined status
        if mask_box:
            x1, y1, x2, y2 = mask_box
            if mask_status == "Mask":
                print(f"‚úÖ {mask_status} detected")
                cv2.rectangle(frame, (x1, y1), (x2, y2), (255, 0, 0), 2)  # Blue for mask
                cv2.putText(frame, f"Mask ({mask_confidence:.2f})", (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 0, 0), 2)
            else:
                print(f"‚ùå {mask_status} detected")
                cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 255), 2)  # Yellow for no mask
                cv2.putText(frame, f"No Mask ({mask_confidence:.2f})", (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 255), 2)

        if intruder_detected and (time.time() - last_intruder_alert_time) > ALERT_COOLDOWN:
            intruder_counter += 1
            alert_message = {"alert": f"üö® Intruder {intruder_counter} detected!"}
            client.publish(mqtt_topic_intruder, json.dumps(alert_message))
            print(f"‚úÖ Sent intruder alert: {alert_message}")
            last_intruder_alert_time = time.time()
            send_email_alert()

        _, buffer = cv2.imencode('.jpg', frame)
        frame = buffer.tobytes()
        yield (b'--frame\r\n'
               b'Content-Type: image/jpeg\r\n\r\n' + frame + b'\r\n')

@app.route('/video_feed')
def video_feed():
    return Response(generate_frames(), mimetype='multipart/x-mixed-replace; boundary=frame')

def cleanup():
    cap.release()
    client.loop_stop()
    client.disconnect()
    print("üßπ Resources cleaned up.")

atexit.register(cleanup)

if __name__ == "__main__":
    print("üöÄ Intruder detection system started. Access video feed at: http://<RASPBERRY_PI_IP>:5000/video_feed")
    app.run(host='0.0.0.0', port=5000, debug=False)